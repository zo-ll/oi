#!/bin/bash
#
# oi - One-command LLM chat interface for llama.cpp
# Interactive model selection and chat launcher
#

# Don't use set -e as it causes issues with the interactive menu loop

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/lib"
LLAMA_CPP_DIR="${HOME}/llama.cpp"
MODELS_DIR="${LLAMA_CPP_DIR}/models"
LLAMA_CLI="${LLAMA_CPP_DIR}/build/bin/llama-cli"
DEFAULT_QUANT="Q4_K_M"
DEFAULT_CONTEXT=4096
CACHE_DIR="${LIB_DIR}/cache"
CACHE_FILE="${CACHE_DIR}/hf_models.json"
CACHE_TTL=86400  # 24 hours
HF_ORGS="Qwen meta-llama microsoft google mistralai bartowski unsloth MaziyarPanahi"

# Colors for output using ANSI escape sequences
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
CYAN=$'\033[0;36m'
NC=$'\033[0m' # No Color

# Terminal-adaptive utilities
get_term_width() {
    local w
    w=$(tput cols 2>/dev/null) || w=80
    (( w < 40 )) && w=40
    (( w > 80 )) && w=80
    echo "$w"
}

make_divider() {
    local width="$1"
    local char="${2:-─}"
    local out=""
    local i
    for (( i=0; i<width; i++ )); do
        out+="$char"
    done
    printf '%s' "$out"
}

truncate_str() {
    local str="$1"
    local max="$2"
    if [ "${#str}" -gt "$max" ]; then
        echo "${str:0:$((max-3))}..."
    else
        echo "$str"
    fi
}

# Help message
show_help() {
    cat <<EOF
oi - One-command LLM chat interface

USAGE:
    oi [OPTIONS]

OPTIONS:
    -m, --model <id>         Directly select model by ID
    -q, --quant <quant>      Specify quantization (default: ${DEFAULT_QUANT})
    -l, --list              List available models
    -i, --installed         List installed models only
    -d, --download <path>   Download custom model from HuggingFace
                            Format: username/repo-name/filename.gguf
    -r, --refresh           Force refresh model catalog from HuggingFace
    -x, --remove <file>     Remove an installed model
    -h, --hardware          Show system hardware information
    -c, --context <size>    Set context size (default: ${DEFAULT_CONTEXT})
    -t, --threads <num>     Set number of CPU threads
    --help                  Show this help message

EXAMPLES:
    oi                      # Interactive model selection
    oi -m qwen2.5-3b        # Start chat with specific model
    oi -m phi-3-mini -q Q5_K_M  # Use specific quantization
    oi -l                   # List all available models
    oi -r -l                # Force refresh catalog from HuggingFace
    oi -x qwen3-8b-q4_k_m.gguf  # Remove an installed model
    oi -d microsoft/Phi-3-mini-4k-instruct-gguf/Phi-3-mini-4k-instruct.Q4_K_M.gguf

QUANTIZATION OPTIONS:
    Q2_K    - Smallest, fastest, lowest quality
    Q3_K_S  - Small and fast, decent quality
    Q3_K_M  - Balanced 3-bit
    Q4_K_M  - Recommended (default)
    Q4_K_L  - High quality 4-bit
    Q5_K_M  - Near-lossless quality
    Q6_K    - Very high quality
    Q8_0    - Best quality, largest

MODEL STORAGE:
    Models are stored in: ${MODELS_DIR}
EOF
}

# Check if llama.cpp is properly set up
check_llama_cpp() {
    if [ ! -d "$LLAMA_CPP_DIR" ]; then
        echo -e "${RED}Error: llama.cpp not found at ${LLAMA_CPP_DIR}${NC}"
        echo "Please clone and build llama.cpp first:"
        echo "  git clone https://github.com/ggml-org/llama.cpp.git ~/llama.cpp"
        echo "  cd ~/llama.cpp && cmake -B build && cmake --build build"
        exit 1
    fi
    
    if [ ! -f "$LLAMA_CLI" ]; then
        echo -e "${RED}Error: llama-cli not found at ${LLAMA_CLI}${NC}"
        echo "Please build llama.cpp:"
        echo "  cd ~/llama.cpp && cmake -B build && cmake --build build"
        exit 1
    fi
    
    mkdir -p "$MODELS_DIR"
}

# Detect system hardware
detect_hardware() {
    if [ -f "${LIB_DIR}/hardware_detect.sh" ]; then
        bash "${LIB_DIR}/hardware_detect.sh"
    else
        echo '{"vram_gb": 0, "ram_gb": 8, "total_memory_gb": 8, "gpu_name": "Unknown", "cuda_available": "no", "cpu_cores": 4}'
    fi
}

# Get hardware summary for display
show_hardware() {
    local hw=$(detect_hardware)
    local vram=$(echo "$hw" | grep -o '"vram_gb": [0-9.]*' | cut -d' ' -f2)
    local ram=$(echo "$hw" | grep -o '"ram_gb": [0-9]*' | cut -d' ' -f2)
    local gpu=$(echo "$hw" | grep -o '"gpu_name": "[^"]*"' | cut -d'"' -f4)
    local cuda=$(echo "$hw" | grep -o '"cuda_available": "[^"]*"' | cut -d'"' -f4)
    local cores=$(echo "$hw" | grep -o '"cpu_cores": [0-9]*' | cut -d' ' -f2)
    
    local w=$(get_term_width)
    local div=$(make_divider "$w")
    local gpu_max=$((w - 14))
    local gpu_display=$(truncate_str "$gpu" "$gpu_max")

    echo -e "${CYAN}Hardware Profile${NC}"
    echo -e "${CYAN}${div}${NC}"
    printf "  ${BLUE}GPU:${NC}         %s\n" "${gpu_display}"
    printf "  ${BLUE}VRAM:${NC}        %.1f GB\n" "${vram}"
    printf "  ${BLUE}CUDA:${NC}        %s\n" "${cuda}"
    printf "  ${BLUE}RAM:${NC}         %s GB\n" "${ram}"
    printf "  ${BLUE}CPU Cores:${NC}   %s\n" "${cores}"
    echo -e "${CYAN}${div}${NC}"

    # Recommendation
    local rec_text="" rec_color=""
    if [ "${cuda}" = "yes" ] && [ "${vram%.*}" -ge 7 ]; then
        rec_color="$GREEN"; rec_text="✓ You can run models up to 7B parameters comfortably"
    elif [ "${cuda}" = "yes" ] && [ "${vram%.*}" -ge 4 ]; then
        rec_color="$YELLOW"; rec_text="● You can run models up to 4B parameters comfortably"
    elif [ "$ram" -ge 16 ]; then
        rec_color="$YELLOW"; rec_text="● CPU-only mode. Models up to 7B will work but slower"
    else
        rec_color="$RED"; rec_text="● Small models only (2-3B parameters)"
    fi
    echo -e "${rec_color}$(truncate_str "$rec_text" "$w")${NC}"
}

# Check if HF model cache is still valid
is_cache_valid() {
    [ -f "$CACHE_FILE" ] || return 1
    local now file_mod age
    now=$(date +%s)
    file_mod=$(stat -c %Y "$CACHE_FILE" 2>/dev/null || stat -f %m "$CACHE_FILE" 2>/dev/null) || return 1
    age=$((now - file_mod))
    [ "$age" -lt "$CACHE_TTL" ]
}

# Fetch GGUF models from HuggingFace, filtered by what fits in host memory
fetch_hf_models() {
    mkdir -p "$CACHE_DIR"
    local hw=$(detect_hardware)
    local total_mem=$(echo "$hw" | grep -o '"total_memory_gb": [0-9.]*' | cut -d' ' -f2)
    echo -e "${YELLOW}Updating model catalog from HuggingFace...${NC}" >&2
    python3 - "$CACHE_FILE" "$HF_ORGS" "$total_mem" <<'PYEOF'
import sys, json, re

try:
    from urllib.request import urlopen, Request
except ImportError:
    sys.exit(1)

cache_path = sys.argv[1]
orgs = sys.argv[2].split()
total_mem_gb = float(sys.argv[3] or "8")

API = "https://huggingface.co/api/models"
QUANT_RE = re.compile(r'[Qq]\d[_.][Kk]?_?[A-Za-z0-9]*|IQ\d[_.][A-Za-z0-9]*')
SHARD_RE = re.compile(r'-\d{5}-of-\d{5}')
PARAM_RE = re.compile(r'(\d+(?:\.\d+)?)\s*[Bb](?:illion)?(?:\b|_)')

def estimate_q4_gb(billions):
    """Estimate Q4_K_M file size in GB from param count in billions."""
    return round(billions * 0.6 + 0.5, 1)

def parse_param_billions(name):
    """Extract parameter count in billions from model name, e.g. '8B' -> 8.0"""
    m = PARAM_RE.search(name)
    if m:
        return float(m.group(1))
    return None

# Pick search size buckets based on total memory
# Rule of thumb: Q4_K_M ≈ 0.6 GB per billion params, plus ~1 GB overhead
size_tags = ["1b", "3b"]
if total_mem_gb >= 8:
    size_tags += ["7b", "8b"]
if total_mem_gb >= 16:
    size_tags += ["14b"]
if total_mem_gb >= 32:
    size_tags += ["30b", "32b", "34b"]
if total_mem_gb >= 64:
    size_tags += ["70b", "72b"]

# Max param count (billions) that fits in total memory at Q4_K_M
max_param_b = (total_mem_gb - 1) / 0.6

def api_get(url):
    req = Request(url, headers={"User-Agent": "oi-cli/1.0"})
    with urlopen(req, timeout=15) as resp:
        return json.loads(resp.read().decode())

seen = {}

for org in orgs:
    for size in size_tags:
        url = (f"{API}?author={org}&search={size}+gguf"
               f"&sort=downloads&direction=-1&limit=5&filter=text-generation")
        try:
            results = api_get(url)
        except Exception:
            continue

        for repo_info in results:
            repo_id = repo_info.get("id", "")
            downloads = repo_info.get("downloads", 0)
            likes = repo_info.get("likes", 0)

            # Estimate param count from repo name and check it fits
            param_b = parse_param_billions(repo_id)
            if param_b and param_b > max_param_b:
                continue

            try:
                details = api_get(f"{API}/{repo_id}")
            except Exception:
                continue

            siblings = details.get("siblings", [])

            # Collect single-file GGUFs only (skip sharded multi-part files)
            gguf_files = []
            for s in siblings:
                fn = s.get("rfilename", "")
                if not fn.endswith(".gguf") or fn.startswith("."):
                    continue
                if SHARD_RE.search(fn):
                    continue  # sharded — skip
                gguf_files.append(s)

            if not gguf_files:
                continue

            # Pick representative file (prefer Q4_K_M)
            rep = None
            for s in gguf_files:
                fn = s["rfilename"]
                if "Q4_K_M" in fn.upper().replace("-", "_"):
                    rep = fn
                    break
            if not rep:
                rep = gguf_files[0]["rfilename"]

            # Build filename template
            m = QUANT_RE.search(rep)
            if m:
                template = rep[:m.start()] + "{quant}" + rep[m.end():]
            else:
                template = rep

            # Estimate min_vram_gb from param count
            if param_b:
                min_vram = estimate_q4_gb(param_b)
            else:
                min_vram = 3.0

            # Derive short CLI id
            repo_name = repo_id.split("/")[-1]
            cli_id = repo_name.lower()
            cli_id = re.sub(r'-gguf$', '', cli_id)
            cli_id = re.sub(r'-instruct', '', cli_id)
            cli_id = re.sub(r'[._]', '-', cli_id)
            cli_id = re.sub(r'-+', '-', cli_id).strip('-')

            # Deduplicate: keep highest download count
            if cli_id in seen:
                if seen[cli_id]["_downloads"] >= downloads:
                    continue

            model_name = repo_name.replace("-GGUF", "").replace("-gguf", "")

            seen[cli_id] = {
                "id": cli_id,
                "name": model_name,
                "repo": repo_id,
                "filename_template": template,
                "min_vram_gb": min_vram,
                "description": f"{downloads:,} downloads, {likes:,} likes on HuggingFace",
                "tags": ["dynamic", org.lower()],
                "_downloads": downloads
            }

models = sorted(seen.values(), key=lambda m: m["_downloads"], reverse=True)
for m in models:
    del m["_downloads"]

output = {"models": models}
with open(cache_path, "w") as f:
    json.dump(output, f, indent=2)

print(f"Fetched {len(models)} models from HuggingFace", file=sys.stderr)
PYEOF
    return $?
}

# Load models catalog:
# - Default: use curated static list from lib/models.json
# - If HF cache exists (from -r refresh), use that instead
# - Fallback: empty list
load_models() {
    # If user has previously fetched from HF with -r, use that cache
    if is_cache_valid; then
        cat "$CACHE_FILE"
        return
    fi

    # Default: use the curated static model list
    if [ -f "${LIB_DIR}/models.json" ]; then
        cat "${LIB_DIR}/models.json"
        return
    fi

    echo '{"models": []}'
}

# Get model info by ID
get_model_info() {
    local model_id="$1"
    local models=$(load_models)
    
    # Extract model entry from JSON - escape model_id for safety
    local escaped_id=$(echo "$model_id" | sed 's/[[\.*^$()+?{|]/\\&/g')
    echo "$models" | grep -A 10 "\"id\": \"${escaped_id}\"" | head -10
}

# Check if model file exists
is_model_installed() {
    local filename="$1"
    [ -f "${MODELS_DIR}/${filename}" ]
}

# Build filename from template and quantization
build_filename() {
    local template="$1"
    local quant="$2"
    
    # If template doesn't contain {quant}, return it as-is (model-specific filename)
    if [[ "$template" != *"{quant}"* ]]; then
        echo "$template"
        return
    fi
    
    echo "${template//\{quant\}/$quant}"
}

# Build HuggingFace download URL
build_hf_url() {
    local repo="$1"
    local filename="$2"
    echo "https://huggingface.co/${repo}/resolve/main/${filename}"
}

# Download model using curl
download_model() {
    local model_id="$1"
    local quant="$2"
    
    local model_info=$(get_model_info "$model_id")
    if [ -z "$model_info" ]; then
        echo -e "${RED}Error: Unknown model ID: ${model_id}${NC}"
        return 1
    fi
    
    local repo=$(echo "$model_info" | grep '"repo":' | head -1 | cut -d'"' -f4)
    local template=$(echo "$model_info" | grep '"filename_template":' | head -1 | cut -d'"' -f4)
    local name=$(echo "$model_info" | grep '"name":' | head -1 | cut -d'"' -f4)
    
    # Check if model has default_quant specified
    local model_default_quant=$(echo "$model_info" | grep '"default_quant":' | head -1 | cut -d'"' -f4)
    if [ -z "$quant" ]; then
        if [ -n "$model_default_quant" ]; then
            quant="$model_default_quant"
        else
            quant="$DEFAULT_QUANT"
        fi
    fi
    
    local filename=$(build_filename "$template" "$quant")
    local url=$(build_hf_url "$repo" "$filename")
    local output_path="${MODELS_DIR}/${filename}"
    
    echo -e "${CYAN}Downloading: ${name}${NC}"
    echo "  Quantization: $quant"
    echo "  URL: $url"
    echo "  Destination: $output_path"
    echo ""
    
    # Check if already exists
    if [ -f "$output_path" ]; then
        echo -e "${YELLOW}Model already exists. Skipping download.${NC}"
        return 0
    fi
    
    # Download with curl
    # Using -C - for resume support, -# for progress bar
    if ! curl -C - -# -L "$url" -o "$output_path"; then
        echo -e "${RED}Error: Download failed${NC}"
        # Clean up partial download
        rm -f "$output_path"
        return 1
    fi
    
    # Verify download (basic size check)
    local size=$(stat -c%s "$output_path" 2>/dev/null || stat -f%z "$output_path" 2>/dev/null)
    if [ "$size" -lt 1000000 ]; then
        echo -e "${RED}Error: Downloaded file is too small (${size} bytes). Download may have failed.${NC}"
        rm -f "$output_path"
        return 1
    fi
    
    echo -e "${GREEN}Download complete: ${filename}${NC}"
    return 0
}

# Download custom model from HF path
download_custom() {
    local hf_path="$1"
    # Parse username/repo-name/filename.gguf
    local parts=$(echo "$hf_path" | tr '/' ' ')
    local repo=$(echo "$parts" | awk '{print $1"/"$2}')
    local filename=$(echo "$parts" | awk '{for(i=3;i<=NF;i++) printf "%s", $i; if(i<=NF) printf "/"}')
    
    if [ -z "$repo" ] || [ -z "$filename" ]; then
        echo -e "${RED}Error: Invalid HuggingFace path${NC}"
        echo "Format: username/repo-name/filename.gguf"
        return 1
    fi
    
    local url=$(build_hf_url "$repo" "$filename")
    local output_path="${MODELS_DIR}/${filename}"
    
    echo -e "${CYAN}Downloading custom model${NC}"
    echo "  URL: $url"
    echo ""
    
    if [ -f "$output_path" ]; then
        echo -e "${YELLOW}Model already exists.${NC}"
        return 0
    fi
    
    if ! curl -C - -# -L "$url" -o "$output_path"; then
        echo -e "${RED}Error: Download failed${NC}"
        rm -f "$output_path"
        return 1
    fi
    
    echo -e "${GREEN}Download complete: ${filename}${NC}"
}

# Remove an installed model
remove_model() {
    local filename="$1"
    local filepath="${MODELS_DIR}/${filename}"

    if [ ! -f "$filepath" ]; then
        echo -e "${RED}Error: Model not found: ${filename}${NC}"
        echo "Use 'oi -i' to list installed models."
        return 1
    fi

    local size=$(du -h "$filepath" 2>/dev/null | cut -f1)
    echo -e "${YELLOW}Model: ${filename}${NC}"
    echo -e "${YELLOW}Size:  ${size}${NC}"
    read -p "Are you sure you want to delete this model? [y/N] " confirm
    case "$confirm" in
        [Yy]|[Yy][Ee][Ss])
            if rm "$filepath"; then
                echo -e "${GREEN}Deleted: ${filename}${NC}"
            else
                echo -e "${RED}Error: Failed to delete ${filename}${NC}"
                return 1
            fi
            ;;
        *)
            echo "Cancelled."
            ;;
    esac
}

# List available models (filtered by hardware)
list_models() {
    local show_all="$1"
    local hw=$(detect_hardware)
    local vram=$(echo "$hw" | grep -o '"vram_gb": [0-9.]*' | cut -d' ' -f2)
    local total_mem=$(echo "$hw" | grep -o '"total_memory_gb": [0-9.]*' | cut -d' ' -f2)
    local w=$(get_term_width)

    echo -e "${CYAN}Available Models:${NC}"
    echo ""

    local models=$(load_models)

    # Parse and display each model
    echo "$models" | grep -E '"id"|"name"|"min_vram_gb"|"description"|"tags"' | while read -r line; do
        if echo "$line" | grep -q '"id":'; then
            id=$(echo "$line" | cut -d'"' -f4)
        elif echo "$line" | grep -q '"name":'; then
            name=$(echo "$line" | cut -d'"' -f4)
        elif echo "$line" | grep -q '"min_vram_gb":'; then
            min_vram=$(echo "$line" | grep -o '"min_vram_gb": [0-9.]*' | grep -o '[0-9.]*' | head -1)

            # Check if model is suitable - convert to integers for comparison
            suitable=""
            if [ "$show_all" != "all" ]; then
                # Use bc for floating point comparison
                if command -v bc >/dev/null 2>&1; then
                    if (( $(echo "$vram >= $min_vram" | bc -l) )); then
                        suitable="${GREEN}[Compatible]${NC}"
                    else
                        suitable="${YELLOW}[CPU Only]${NC}"
                    fi
                else
                    # Fallback: compare integer parts
                    local vram_int=$(echo "$vram" | cut -d. -f1)
                    local min_vram_int=$(echo "$min_vram" | cut -d. -f1)
                    if [ "$vram_int" -ge "$min_vram_int" ]; then
                        suitable="${GREEN}[Compatible]${NC}"
                    else
                        suitable="${YELLOW}[CPU Only]${NC}"
                    fi
                fi
            fi

            # Check if installed
            local template=$(echo "$models" | grep -A 10 "\"id\": \"${id}\"" | grep '"filename_template":' | cut -d'"' -f4)
            local filename=$(build_filename "$template" "$DEFAULT_QUANT")
            local installed=""
            if is_model_installed "$filename"; then
                installed=" ${GREEN}[Installed]${NC}"
            fi

            # Truncate the header line: "id: name [status][installed]"
            local header_plain="${id}: ${name}"
            local header_max=$((w - 15))  # room for status markers
            header_plain=$(truncate_str "$header_plain" "$header_max")
            echo -e "${BLUE}${header_plain}${NC} ${suitable}${installed}"
            echo "    Min VRAM: ${min_vram} GB"
        elif echo "$line" | grep -q '"description":'; then
            desc=$(echo "$line" | cut -d'"' -f4)
            # Only print if we have a valid model context (id is set)
            if [ -n "$id" ] && [ -n "$name" ]; then
                echo "    $(truncate_str "$desc" $((w - 4)))"
                echo ""
                # Reset variables for next model
                id=""
                name=""
                min_vram=""
            fi
        fi
    done
}

# List installed models only
list_installed_models() {
    local w=$(get_term_width)
    echo -e "${CYAN}Installed Models:${NC}"
    echo ""

    local found=0
    for file in "$MODELS_DIR"/*.gguf; do
        if [ -f "$file" ]; then
            found=1
            local basename=$(basename "$file")
            local size=$(du -h "$file" 2>/dev/null | cut -f1)
            local suffix=" (${size})"
            local name_max=$((w - ${#suffix} - 2))  # 2 for "✓ "
            local display_name=$(truncate_str "$basename" "$name_max")
            echo -e "${GREEN}✓${NC} ${display_name}${suffix}"
        fi
    done

    if [ "$found" -eq 0 ]; then
        echo "No models installed yet."
        echo "Run 'oi' to download and install models."
    fi
}

# Get compatible models for interactive selection
get_compatible_models() {
    local hw=$(detect_hardware)
    local vram=$(echo "$hw" | grep -o '"vram_gb": [0-9.]*' | cut -d' ' -f2)
    local total_mem=$(echo "$hw" | grep -o '"total_memory_gb": [0-9.]*' | cut -d' ' -f2)
    
    local models=$(load_models)
    local compatible=""
    
    # Build list of compatible models
    local ids=$(echo "$models" | grep '"id":' | cut -d'"' -f4)
    for id in $ids; do
        local model_info=$(echo "$models" | grep -A 10 "\"id\": \"${id}\"" | head -10)
        local min_vram=$(echo "$model_info" | grep '"min_vram_gb":' | grep -o '[0-9.]*' | head -1)
        local name=$(echo "$model_info" | grep '"name":' | head -1 | cut -d'"' -f4)
        
        if [ -n "$min_vram" ]; then
            local status=""
            # Use bc for floating point comparison if available
            if command -v bc >/dev/null 2>&1; then
                if (( $(echo "$vram >= $min_vram" | bc -l) )); then
                    status="gpu"
                elif (( $(echo "$total_mem >= $min_vram" | bc -l) )); then
                    status="cpu"
                fi
            else
                # Fallback: compare integer parts
                local vram_int=$(echo "$vram" | cut -d. -f1)
                local total_mem_int=$(echo "$total_mem" | cut -d. -f1)
                local min_vram_int=$(echo "$min_vram" | cut -d. -f1)
                if [ "$vram_int" -ge "$min_vram_int" ]; then
                    status="gpu"
                elif [ "$total_mem_int" -ge "$min_vram_int" ]; then
                    status="cpu"
                fi
            fi
            
            if [ -n "$status" ]; then
                compatible="${compatible}${id}|${name}|${status}
"
            fi
        fi
    done
    
    echo -e "$compatible"
}

# Check if a model is installed
is_model_in_array() {
    local target="$1"
    shift
    local arr=("$@")
    for item in "${arr[@]}"; do
        if [ "$item" = "$target" ]; then
            return 0
        fi
    done
    return 1
}

# Draw the full menu UI once
draw_full_menu() {
    local w=$(get_term_width)
    local inner=$((w - 2))  # inside the box border chars

    # Output all UI to stderr so only the model ID goes to stdout
    # Dynamic banner
    local title="oi - LLM Chat Interface"
    local pad_total=$((inner - ${#title}))
    local pad_left=$((pad_total / 2))
    local pad_right=$((pad_total - pad_left))
    echo -e "${CYAN}╔$(make_divider "$inner" "═")╗${NC}" >&2
    printf >&2 "${CYAN}║${NC}%*s%s%*s${CYAN}║${NC}\n" "$pad_left" "" "$title" "$pad_right" ""
    echo -e "${CYAN}╚$(make_divider "$inner" "═")╝${NC}" >&2

    # Hardware section — compact if terminal is short
    local term_h
    term_h=$(tput lines 2>/dev/null) || term_h=40
    if (( term_h < 20 )); then
        # One-line hardware summary
        local hw=$(detect_hardware)
        local vram=$(echo "$hw" | grep -o '"vram_gb": [0-9.]*' | cut -d' ' -f2)
        local ram=$(echo "$hw" | grep -o '"ram_gb": [0-9]*' | cut -d' ' -f2)
        echo -e "${CYAN}VRAM: ${vram}G  RAM: ${ram}G${NC}" >&2
    else
        show_hardware >&2
    fi

    # Get all models and check which are installed
    local models=$(load_models)
    local ids=$(echo "$models" | grep '"id":' | cut -d'"' -f4)
    local installed=()

    for id in $ids; do
        local model_info=$(echo "$models" | grep -A 10 "\"id\": \"${id}\"" | head -10)
        local template=$(echo "$model_info" | grep '"filename_template":' | head -1 | cut -d'"' -f4)
        local filename=$(build_filename "$template" "$DEFAULT_QUANT")
        if is_model_installed "$filename"; then
            installed+=("$id")
        fi
    done

    # Build single list of all compatible models
    local compatible=$(get_compatible_models)
    local all_ids=()
    local all_names=()
    local all_status=()

    while IFS='|' read -r id name status; do
        [ -z "$id" ] && continue
        all_ids+=("$id")
        all_names+=("$name")
        all_status+=("$status")
    done <<< "$compatible"

    # Show single unified menu
    echo -e "${BLUE}Available Models:${NC}" >&2
    echo -e "${BLUE}$(make_divider "$w")${NC}" >&2

    # Compute how many models we can show
    local total_models=${#all_ids[@]}
    local max_models=$total_models
    # Reserve lines: 3 banner + hw(~8 or 1) + 2 header/divider + 3 footer + 2 prompt = ~18 or ~11
    local reserved_lines=10
    if (( term_h < 20 )); then reserved_lines=7; fi
    local avail_lines=$((term_h - reserved_lines))
    if (( avail_lines < 3 )); then avail_lines=3; fi
    if (( max_models > avail_lines )); then
        max_models=$((avail_lines - 1))  # leave room for overflow indicator
    fi

    # Figure out name column width: w - "  N) " (5) - " ● GPU" (6) - " ✓" (2) - padding (2)
    local name_max=$((w - 15))
    (( name_max < 10 )) && name_max=10

    local i=1
    for idx in "${!all_ids[@]}"; do
        if (( i > max_models )) && (( total_models > max_models )); then
            local remaining=$((total_models - max_models))
            echo -e "  ${YELLOW}... ${remaining} more (press L)${NC}" >&2
            break
        fi

        local id="${all_ids[$idx]}"
        local name="${all_names[$idx]}"
        local status="${all_status[$idx]}"

        local status_str=""
        if [ "$status" = "gpu" ]; then
            status_str="${GREEN}●${NC} GPU"
        else
            status_str="${YELLOW}●${NC} CPU"
        fi

        # Truncate name and use short installed marker
        local display_name=$(truncate_str "$name" "$name_max")
        local installed_marker=""
        if is_model_in_array "$id" "${installed[@]}"; then
            installed_marker=" ${GREEN}✓${NC}"
        fi

        printf >&2 "  %-2s %-${name_max}s %s%s\n" "$i)" "$display_name" "$status_str" "$installed_marker"
        ((i++))
    done

    echo -e "${BLUE}$(make_divider "$w")${NC}" >&2
    echo -e "  ${CYAN}L${NC}) List all available models" >&2
    echo -e "  ${CYAN}D${NC}) Delete an installed model" >&2
    echo -e "  ${CYAN}H${NC}) Show hardware info" >&2
    echo -e "  ${CYAN}Q${NC}) Quit" >&2
}

# Interactive model selection
interactive_select() {
    # Draw the full menu once at startup
    draw_full_menu
    
    # Get all models and check which are installed (needed for the choice handling)
    local models=$(load_models)
    local ids=$(echo "$models" | grep '"id":' | cut -d'"' -f4)
    local installed=()
    
    for id in $ids; do
        local model_info=$(echo "$models" | grep -A 10 "\"id\": \"${id}\"" | head -10)
        local template=$(echo "$model_info" | grep '"filename_template":' | head -1 | cut -d'"' -f4)
        local filename=$(build_filename "$template" "$DEFAULT_QUANT")
        if is_model_installed "$filename"; then
            installed+=("$id")
        fi
    done
    
    # Build single list of all compatible models
    local compatible=$(get_compatible_models)
    local all_ids=()
    local all_names=()
    local all_status=()
    
    while IFS='|' read -r id name status; do
        [ -z "$id" ] && continue
        all_ids+=("$id")
        all_names+=("$name")
        all_status+=("$status")
    done <<< "$compatible"
    
    # Main interaction loop - only redraws the prompt after L/H commands
    while true; do
        # Read selection - only redraw this prompt line
        local w=$(get_term_width)
        local box_inner=$((w - 2))
        echo -e "${CYAN}┌$(make_divider "$box_inner")┐${NC}" >&2
        read -p "│ Enter choice (1-${#all_ids[@]}, L, D, H, Q): " choice
        # Clear the input line and draw bottom border on same line
        echo -e "\r${CYAN}└$(make_divider "$box_inner")┘${NC}" >&2
        
        case "$choice" in
            [Ll])
                list_models >&2
                echo "" >&2
                sleep 2
                # Continue loop to redraw only the prompt
                continue
                ;;
            [Hh])
                show_hardware >&2
                echo "" >&2
                sleep 1
                # Continue loop to redraw only the prompt
                continue
                ;;
            [Dd])
                # List installed models for selection (skip small vocab/test files)
                local del_files=()
                local del_i=1
                for f in "$MODELS_DIR"/*.gguf; do
                    [ -f "$f" ] || continue
                    local fsize=$(stat -c%s "$f" 2>/dev/null || stat -f%z "$f" 2>/dev/null)
                    [ "$fsize" -lt 100000000 ] && continue  # skip files < 100MB
                    del_files+=("$(basename "$f")")
                    local del_size=$(du -h "$f" 2>/dev/null | cut -f1)
                    echo -e "  ${del_i}) $(basename "$f") (${del_size})" >&2
                    ((del_i++))
                done
                if [ ${#del_files[@]} -eq 0 ]; then
                    echo -e "${YELLOW}No installed models to delete.${NC}" >&2
                    continue
                fi
                read -p "Select model to delete (1-${#del_files[@]}, or C to cancel): " del_choice
                if [[ "$del_choice" =~ ^[Cc]$ ]]; then
                    continue
                fi
                if [[ "$del_choice" =~ ^[0-9]+$ ]] && [ "$del_choice" -ge 1 ] && [ "$del_choice" -le ${#del_files[@]} ]; then
                    remove_model "${del_files[$((del_choice - 1))]}"
                else
                    echo -e "${RED}Invalid selection${NC}" >&2
                fi
                continue
                ;;
            [Qq])
                echo -e "${GREEN}Goodbye!${NC}" >&2
                return 2
                ;;
            *)
                if [[ "$choice" =~ ^[0-9]+$ ]]; then
                    local idx=$((choice - 1))
                    
                    # Simple index lookup in unified list
                    if [ $idx -ge 0 ] && [ $idx -lt ${#all_ids[@]} ]; then
                        local selected_id="${all_ids[$idx]}"
                        # This goes to stdout - the only thing captured by command substitution
                        echo "$selected_id"
                        return 0
                    else
                        echo -e "${RED}Invalid selection${NC}" >&2
                        # Continue loop to redraw only the prompt
                        continue
                    fi
                else
                    # Try direct ID
                    if get_model_info "$choice" > /dev/null; then
                        echo "$choice"
                        return 0
                    else
                        echo -e "${RED}Unknown model ID: $choice${NC}" >&2
                        # Continue loop to redraw only the prompt
                        continue
                    fi
                fi
                ;;
        esac
    done
}

# Launch chat with selected model
launch_chat() {
    local model_id="$1"
    local quant="$2"
    local context="${3:-$DEFAULT_CONTEXT}"
    local threads="${4:-$(nproc)}"
    
    local model_info=$(get_model_info "$model_id")
    if [ -z "$model_info" ]; then
        echo -e "${RED}Error: Unknown model ID: ${model_id}${NC}"
        return 1
    fi
    
    # Check for model-specific default_quant
    local model_default_quant=$(echo "$model_info" | grep '"default_quant":' | head -1 | cut -d'"' -f4)
    if [ -z "$quant" ]; then
        if [ -n "$model_default_quant" ]; then
            quant="$model_default_quant"
        else
            quant="$DEFAULT_QUANT"
        fi
    fi
    
    local template=$(echo "$model_info" | grep '"filename_template":' | head -1 | cut -d'"' -f4)
    local filename=$(build_filename "$template" "$quant")
    local model_path="${MODELS_DIR}/${filename}"
    local name=$(echo "$model_info" | grep '"name":' | head -1 | cut -d'"' -f4)
    
    # Check if model exists, download if not
    if [ ! -f "$model_path" ]; then
        echo -e "${YELLOW}Model not found locally. Downloading...${NC}"
        if ! download_model "$model_id" "$quant"; then
            return 1
        fi
    fi
    
    # Verify file exists after potential download
    if [ ! -f "$model_path" ]; then
        echo -e "${RED}Error: Model file not found: $model_path${NC}"
        return 1
    fi
    
    echo -e "${GREEN}Starting chat with: ${name}${NC}"
    echo "  Model: $filename"
    echo "  Context: $context"
    echo "  Threads: $threads"
    echo ""
    echo -e "${CYAN}Type your message and press Enter. Use Ctrl+C to exit.${NC}"
    echo "$(make_divider "$(get_term_width)")"
    
    # Launch llama-cli in interactive mode
    "$LLAMA_CLI" \
        -m "$model_path" \
        -c "$context" \
        -t "$threads" \
        -n -1
}

# Main function
main() {
    # Parse arguments
    local model_id=""
    local quant="$DEFAULT_QUANT"
    local context="$DEFAULT_CONTEXT"
    local threads="$(nproc)"
    local list_mode=""
    local download_path=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -m|--model)
                model_id="$2"
                shift 2
                ;;
            -q|--quant)
                quant="$2"
                shift 2
                ;;
            -c|--context)
                context="$2"
                shift 2
                ;;
            -t|--threads)
                threads="$2"
                shift 2
                ;;
            -r|--refresh)
                rm -f "$CACHE_FILE"
                fetch_hf_models
                shift
                ;;
            -l|--list)
                list_mode="all"
                shift
                ;;
            -i|--installed)
                list_mode="installed"
                shift
                ;;
            -x|--remove)
                remove_file="$2"
                shift 2
                ;;
            -d|--download)
                download_path="$2"
                shift 2
                ;;
            -h|--hardware)
                check_llama_cpp
                show_hardware
                exit 0
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Check llama.cpp setup
    check_llama_cpp
    
    # Handle list modes
    if [ "$list_mode" = "all" ]; then
        list_models
        exit 0
    elif [ "$list_mode" = "installed" ]; then
        list_installed_models
        exit 0
    fi
    
    # Handle model removal
    if [ -n "$remove_file" ]; then
        remove_model "$remove_file"
        exit $?
    fi

    # Handle custom download
    if [ -n "$download_path" ]; then
        download_custom "$download_path"
        exit $?
    fi
    
    # Main flow
    if [ -n "$model_id" ]; then
        # Direct model selection
        launch_chat "$model_id" "$quant" "$context" "$threads"
    else
        # Interactive mode
        while true; do
            selected=$(interactive_select)
            local select_status=$?
            
            if [ $select_status -eq 0 ]; then
                # User selected a model number
                launch_chat "$selected" "$quant" "$context" "$threads"
                echo -e "\n${GRAY}Returning to model selection...${NC}\n"
            elif [ $select_status -eq 2 ]; then
                # User selected Q to quit
                exit 0
            fi
            # Otherwise (status 1), loop continues for L or H selection
        done
    fi
}

# Run main
main "$@"
